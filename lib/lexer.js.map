{"version":3,"sources":["lexer.js"],"names":["lexer","lex","findTextEnd","lexText","lexComment","lexTag","isWhitespaceChar","lexTagName","lexTagAttributes","lexSkipTag","str","options","state","cursor","tokens","len","length","start","isComment","tagName","safeTag","toLowerCase","childlessTags","alphanumeric","index","textEnd","indexOf","char","charAt","test","type","content","slice","push","commentEnd","secondChar","close","firstChar","whitespace","isTagChar","end","quote","wordBegin","words","isQuoteEnd","isTagEnd","isWordEnd","isQuoteStart","wLen","i","word","isNotPair","secondWord","newWord","thirdWord","nextTag","tagState","name","safeTagName","openTag","closeTag"],"mappings":"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","file":"lexer.js","sourcesContent":["import {\n  startsWith,\n  endsWith,\n  stringIncludes,\n  arrayIncludes\n} from './compat'\n\nexport default function lexer (str, options) {\n  const state = {str, options, cursor: 0, tokens: []}\n  lex(state)\n  return state.tokens\n}\n\nexport function lex (state) {\n  const {str} = state\n  const len = str.length\n  while (state.cursor < len) {\n    const start = state.cursor\n    lexText(state)\n    if (state.cursor === start) {\n      const isComment = startsWith(str, '!--', state.cursor + 1)\n      if (isComment) {\n        lexComment(state)\n      } else {\n        const tagName = lexTag(state)\n        const safeTag = tagName.toLowerCase()\n        const {childlessTags} = state.options\n        if (arrayIncludes(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state)\n        }\n      }\n    }\n  }\n}\n\nconst alphanumeric = /[A-Za-z0-9]/\nexport function findTextEnd (str, index) {\n  while (true) {\n    const textEnd = str.indexOf('<', index)\n    if (textEnd === -1) {\n      return textEnd\n    }\n    const char = str.charAt(textEnd + 1)\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd\n    }\n    index = textEnd + 1\n  }\n}\n\nexport function lexText (state) {\n  const type = 'text'\n  const {str, cursor} = state\n  const textEnd = findTextEnd(str, cursor)\n  if (textEnd === -1) {\n    // there is only text left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  if (textEnd === cursor) return\n\n  const content = str.slice(cursor, textEnd)\n  state.cursor = textEnd\n  state.tokens.push({type, content})\n}\n\nexport function lexComment (state) {\n  state.cursor += 4 // \"<!--\".length\n  const {str, cursor} = state\n  const commentEnd = str.indexOf('-->', cursor)\n  const type = 'comment'\n  if (commentEnd === -1) {\n    // there is only the comment left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  const content = str.slice(cursor, commentEnd)\n  state.cursor = commentEnd + 3 // \"-->\".length\n  state.tokens.push({type, content})\n}\n\nexport function lexTag (state) {\n  const {str} = state\n  {\n    const secondChar = str.charAt(state.cursor + 1)\n    const close = secondChar === '/'\n    state.tokens.push({type: 'tag-start', close})\n    state.cursor += close ? 2 : 1\n  }\n  const tagName = lexTagName(state)\n  lexTagAttributes(state)\n  {\n    const firstChar = str.charAt(state.cursor)\n    const close = firstChar === '/'\n    state.tokens.push({type: 'tag-end', close})\n    state.cursor += close ? 2 : 1\n  }\n  return tagName\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nconst whitespace = /\\s/\nexport function isWhitespaceChar (char) {\n  return whitespace.test(char)\n}\n\nexport function lexTagName (state) {\n  const {str, cursor} = state\n  const len = str.length\n  let start = cursor\n  while (start < len) {\n    const char = str.charAt(start)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (isTagChar) break\n    start++\n  }\n\n  let end = start + 1\n  while (end < len) {\n    const char = str.charAt(end)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (!isTagChar) break\n    end++\n  }\n\n  state.cursor = end\n  const tagName = str.slice(start, end)\n  state.tokens.push({type: 'tag', content: tagName})\n  return tagName\n}\n\nexport function lexTagAttributes (state) {\n  const {str, tokens} = state\n  let cursor = state.cursor\n  let quote = null // null, single-, or double-quote\n  let wordBegin = cursor // index of word start\n  const words = [] // \"key\", \"key=value\", \"key='value'\", etc\n  const len = str.length\n  while (cursor < len) {\n    const char = str.charAt(cursor)\n    if (quote) {\n      const isQuoteEnd = char === quote\n      if (isQuoteEnd) {\n        quote = null\n      }\n      cursor++\n      continue\n    }\n\n    const isTagEnd = char === '/' || char === '>'\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      break\n    }\n\n    const isWordEnd = isWhitespaceChar(char)\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      wordBegin = cursor + 1\n      cursor++\n      continue\n    }\n\n    const isQuoteStart = char === '\\'' || char === '\"'\n    if (isQuoteStart) {\n      quote = char\n      cursor++\n      continue\n    }\n\n    cursor++\n  }\n  state.cursor = cursor\n\n  const wLen = words.length\n  const type = 'attribute'\n  for (let i = 0; i < wLen; i++) {\n    const word = words[i]\n    const isNotPair = word.indexOf('=') === -1\n    if (isNotPair) {\n      const secondWord = words[i + 1]\n      if (secondWord && startsWith(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          const newWord = word + secondWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n        const thirdWord = words[i + 2]\n        i += 1\n        if (thirdWord) {\n          const newWord = word + '=' + thirdWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n      }\n    }\n    if (endsWith(word, '=')) {\n      const secondWord = words[i + 1]\n      if (secondWord && !stringIncludes(secondWord, '=')) {\n        const newWord = word + secondWord\n        tokens.push({type, content: newWord})\n        i += 1\n        continue\n      }\n\n      const newWord = word.slice(0, -1)\n      tokens.push({type, content: newWord})\n      continue\n    }\n\n    tokens.push({type, content: word})\n  }\n}\n\nexport function lexSkipTag (tagName, state) {\n  const {str, cursor, tokens} = state\n  const len = str.length\n  let index = cursor\n  while (index < len) {\n    const nextTag = str.indexOf('</', index)\n    if (nextTag === -1) {\n      lexText(state)\n      break\n    }\n\n    const tagState = {str, cursor: nextTag + 2, tokens: []}\n    const name = lexTagName(tagState)\n    const safeTagName = tagName.toLowerCase()\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.cursor\n      continue\n    }\n\n    const content = str.slice(cursor, nextTag)\n    tokens.push({type: 'text', content})\n    const openTag = {type: 'tag-start', close: true}\n    const closeTag = {type: 'tag-end', close: false}\n    lexTagAttributes(tagState)\n    tokens.push(openTag, ...tagState.tokens, closeTag)\n    state.cursor = tagState.cursor + 1\n    break\n  }\n}\n"]}