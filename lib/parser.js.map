{"version":3,"sources":["parser.js"],"names":["parser","hasTerminalParent","parse","tokens","options","elementCallback","root","tagName","children","state","cursor","stack","terminals","tagParents","currentIndex","length","parentTagName","nodes","len","token","type","push","tagToken","content","toLowerCase","close","item","pop","endToken","isClosingTag","closingTags","shouldRewindToAutoClose","closingTagAncestorBreakers","slice","previousIndex","attributes","attrToken","attributeObject","Object","keys","nodeObject","hasChildren","voidTags","innerState"],"mappings":"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","file":"parser.js","sourcesContent":["import AttParser from './parse-attributes'\nimport {arrayIncludes} from './compat'\n\nexport default function parser (tokens, options, elementCallback) {\n  const root = {tagName: null, children: []}\n  const state = {tokens, options, cursor: 0, stack: [root]}\n  parse(state, elementCallback)\n  return root.children\n}\n\nexport function hasTerminalParent (tagName, stack, terminals) {\n  const tagParents = terminals[tagName]\n  if (tagParents) {\n    let currentIndex = stack.length - 1\n    while (currentIndex >= 0) {\n      const parentTagName = stack[currentIndex].tagName\n      if (parentTagName === tagName) {\n        break\n      }\n      if (arrayIncludes(tagParents, parentTagName)) {\n        return true\n      }\n      currentIndex--\n    }\n  }\n  return false\n}\n\nexport function parse (state, elementCallback) {\n  const {tokens, options} = state\n  let {stack} = state\n  let nodes = stack[stack.length - 1].children\n  const len = tokens.length\n  let {cursor} = state\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      nodes.push(token)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content.toLowerCase()\n    if (token.close) {\n      let item\n      while ((item = stack.pop())) {\n        if (tagName === item.tagName) break\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      break\n    }\n\n    const isClosingTag = arrayIncludes(options.closingTags, tagName)\n    let shouldRewindToAutoClose = isClosingTag\n    if (shouldRewindToAutoClose) {\n      const { closingTagAncestorBreakers: terminals } = options\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals)\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    let attributes = []\n    let attrToken\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n\n      // Parse the attribute partial string.\n      let attributeObject = AttParser(attrToken.content)\n\n      // Only add to the attributes object if it was a valid attribute string partial.\n      if (typeof attributeObject === 'object' && Object.keys(attributeObject).length !== 0) {\n        attributes.push(attributeObject)\n      }\n\n      cursor++\n    }\n\n    cursor++\n    const children = []\n\n    let nodeObject = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes,\n      children\n    }\n\n    // If defined, process the object with the callback function.\n    if (typeof elementCallback === 'function') {\n      elementCallback(nodeObject)\n    }\n    nodes.push(nodeObject)\n\n    const hasChildren = !(attrToken.close || arrayIncludes(options.voidTags, tagName))\n    if (hasChildren) {\n      stack.push({tagName, children})\n      const innerState = {tokens, options, cursor, stack}\n      parse(innerState, elementCallback)\n      cursor = innerState.cursor\n    }\n  }\n  state.cursor = cursor\n}\n"]}